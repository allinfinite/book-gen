import { jsPDF } from "jspdf";
import { BookProject } from "@/types/book";

/**
 * Generate a PDF with Amazon KDP-compatible formatting
 * Standard 6x9" trade paperback size with proper margins
 */
export async function generatePDF(project: BookProject): Promise<Blob> {
  // KDP standard 6x9 trim size in points (1 inch = 72 points)
  const pageWidth = 6 * 72; // 432 points
  const pageHeight = 9 * 72; // 648 points

  // KDP recommended margins for 6x9 (in inches)
  const margins = {
    top: 0.75 * 72, // 54 points
    bottom: 0.75 * 72,
    outside: 0.75 * 72, // right for odd pages, left for even pages
    inside: 0.875 * 72, // left for odd pages (gutter), right for even pages
  };

  const doc = new jsPDF({
    unit: "pt",
    format: [pageWidth, pageHeight],
    orientation: "portrait",
  });

  let pageNumber = 1;

  // Helper function to add header/footer
  const addPageElements = (isOddPage: boolean) => {
    // Page number at bottom center
    doc.setFontSize(10);
    doc.setFont("times", "normal");
    doc.text(
      pageNumber.toString(),
      pageWidth / 2,
      pageHeight - margins.bottom / 2,
      { align: "center" }
    );

    // Running header (book title on even pages, chapter title on odd pages)
    if (pageNumber > 1) {
      doc.setFontSize(9);
      doc.setFont("times", "italic");
      const headerText = isOddPage ? project.meta.title : (project.meta.authorName || "Unknown Author");
      const headerX = isOddPage ? pageWidth - margins.outside : margins.outside;
      const headerAlign = isOddPage ? "right" : "left";
      doc.text(headerText, headerX, margins.top / 2, { align: headerAlign as any });
    }
  };

  // Calculate text area
  const getTextX = (isOddPage: boolean) =>
    isOddPage ? margins.inside : margins.outside;
  const getTextWidth = () => pageWidth - margins.inside - margins.outside;
  const textY = margins.top;
  const textHeight = pageHeight - margins.top - margins.bottom;

  let currentY = textY;
  let isOddPage = true;

  // Helper to add new page
  const addPage = () => {
    doc.addPage();
    pageNumber++;
    isOddPage = !isOddPage;
    addPageElements(isOddPage);
    currentY = textY;
  };

  // Helper to check if we need a new page
  const checkPageBreak = (neededHeight: number) => {
    if (currentY + neededHeight > pageHeight - margins.bottom) {
      addPage();
      return true;
    }
    return false;
  };

  // Title Page (page 1)
  doc.setFont("times", "bold");
  doc.setFontSize(36);
  const titleLines = doc.splitTextToSize(project.meta.title, getTextWidth());
  const titleHeight = titleLines.length * 36 * 1.2;
  const titleY = pageHeight / 2 - titleHeight / 2;
  doc.text(titleLines, pageWidth / 2, titleY, {
    align: "center",
    lineHeightFactor: 1.2,
  });

  if (project.meta.subtitle) {
    doc.setFontSize(18);
    doc.setFont("times", "normal");
    const subtitleY = titleY + titleHeight + 20;
    doc.text(project.meta.subtitle, pageWidth / 2, subtitleY, {
      align: "center",
    });
  }

  doc.setFontSize(24);
  doc.setFont("times", "normal");
  const authorY = pageHeight - pageHeight / 3;
  doc.text(project.meta.authorName || "Unknown Author", pageWidth / 2, authorY, { align: "center" });

  addPageElements(isOddPage);

  // Copyright Page (page 2)
  addPage();
  doc.setFontSize(10);
  doc.setFont("times", "normal");
  const copyrightText = [
    `${project.meta.title}`,
    "",
    `Copyright © ${new Date().getFullYear()} by ${project.meta.authorName || "Unknown Author"}`,
    "",
    "All rights reserved. No part of this book may be reproduced in any form or by any electronic",
    "or mechanical means, including information storage and retrieval systems, without written",
    "permission from the author, except for the use of brief quotations in a book review.",
    "",
    "Generated by BookGen",
  ].filter(Boolean);

  copyrightText.forEach((line, index) => {
    doc.text(line, getTextX(isOddPage), currentY + index * 14);
  });

  // Table of Contents (page 3)
  addPage();
  doc.setFontSize(24);
  doc.setFont("times", "bold");
  doc.text("Table of Contents", pageWidth / 2, currentY, { align: "center" });
  currentY += 40;

  doc.setFontSize(12);
  doc.setFont("times", "normal");
  project.chapters.forEach((chapter, index) => {
    if (checkPageBreak(20)) {
      // Recalculate after page break
    }
    const chapterText = `Chapter ${index + 1}: ${chapter.title}`;
    doc.text(chapterText, getTextX(isOddPage), currentY);
    currentY += 20;
  });

  // Chapters
  project.chapters.forEach((chapter, chapterIndex) => {
    // Start each chapter on a new page
    addPage();

    // Chapter title
    doc.setFontSize(24);
    doc.setFont("times", "bold");
    const chapterTitle = `Chapter ${chapterIndex + 1}`;
    doc.text(chapterTitle, pageWidth / 2, currentY, { align: "center" });
    currentY += 30;

    doc.setFontSize(20);
    const chapterName = chapter.title;
    const chapterNameLines = doc.splitTextToSize(chapterName, getTextWidth());
    doc.text(chapterNameLines, pageWidth / 2, currentY, {
      align: "center",
      lineHeightFactor: 1.2,
    });
    currentY += chapterNameLines.length * 20 * 1.2 + 30;

    // Sections
    chapter.sections.forEach((section, sectionIndex) => {
      // Section title
      if (section.title && section.title !== "Opening") {
        checkPageBreak(30);
        doc.setFontSize(16);
        doc.setFont("times", "bold");
        const sectionLines = doc.splitTextToSize(section.title, getTextWidth());
        doc.text(sectionLines, getTextX(isOddPage), currentY, {
          lineHeightFactor: 1.2,
        });
        currentY += sectionLines.length * 16 * 1.2 + 20;
      }

      // Section content
      if (section.content) {
        doc.setFontSize(12);
        doc.setFont("times", "normal");

        // Convert HTML to plain text
        const plainText = htmlToPlainText(section.content);

        // Split into paragraphs
        const paragraphs = plainText
          .split(/\n\n+/)
          .map((p) => p.trim())
          .filter((p) => p.length > 0);

        paragraphs.forEach((paragraph, pIndex) => {
          // Check if we need a new page
          const lines = doc.splitTextToSize(paragraph, getTextWidth());
          const paragraphHeight = lines.length * 12 * 1.5 + 10;

          checkPageBreak(paragraphHeight);

          // First paragraph after section title is not indented
          const indent = sectionIndex === 0 && pIndex === 0 ? 0 : 20;

          doc.text(lines, getTextX(isOddPage) + indent, currentY, {
            lineHeightFactor: 1.5,
            align: "justify",
            maxWidth: getTextWidth() - indent,
          });

          currentY += lines.length * 12 * 1.5 + 10;
        });
      }
    });
  });

  // Convert to blob
  const pdfBlob = doc.output("blob");
  return pdfBlob;
}

/**
 * Convert HTML to plain text, preserving structure
 */
function htmlToPlainText(html: string): string {
  if (!html) return "";

  // Replace common HTML tags with appropriate text equivalents
  let text = html;

  // Headings
  text = text.replace(/<h[1-6][^>]*>(.*?)<\/h[1-6]>/gi, "\n\n$1\n\n");

  // Paragraphs
  text = text.replace(/<p[^>]*>/gi, "\n\n");
  text = text.replace(/<\/p>/gi, "");

  // Line breaks
  text = text.replace(/<br\s*\/?>/gi, "\n");

  // Lists
  text = text.replace(/<li[^>]*>/gi, "\n• ");
  text = text.replace(/<\/li>/gi, "");
  text = text.replace(/<\/?[ou]l[^>]*>/gi, "\n");

  // Bold and italic (keep them as plain text for now)
  text = text.replace(/<strong[^>]*>(.*?)<\/strong>/gi, "$1");
  text = text.replace(/<b[^>]*>(.*?)<\/b>/gi, "$1");
  text = text.replace(/<em[^>]*>(.*?)<\/em>/gi, "$1");
  text = text.replace(/<i[^>]*>(.*?)<\/i>/gi, "$1");

  // Blockquotes
  text = text.replace(/<blockquote[^>]*>/gi, "\n\n");
  text = text.replace(/<\/blockquote>/gi, "\n\n");

  // Remove remaining HTML tags
  text = text.replace(/<[^>]+>/g, "");

  // Decode HTML entities
  text = text
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'");

  // Clean up extra whitespace
  text = text.replace(/\n\n\n+/g, "\n\n");
  text = text.replace(/^\n+|\n+$/g, "");

  return text.trim();
}

/**
 * Download the PDF file
 */
export function downloadPDF(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `${filename}.pdf`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

